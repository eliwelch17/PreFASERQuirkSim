#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
#include <random>
#include <deque>
#include <deque>
#include <functional>
#include <iomanip>
#include <string>
#include <chrono>
#include <sstream>
#include <stdexcept>
#include <filesystem>
#include <limits>
#include <unordered_map>
#include <tuple>
#include <functional>
#include <utility>
#include <algorithm>
#include <sys/stat.h>
#include <filesystem>
#include <unistd.h> 
#include <cstring> 
#include <array>
#include <map>



#include "include/KDTree3D.h"
#include "include/LifeTimeCalc.h"

// Precomputed ionization-loss range tables (generated by tools/generate_range_tables.py)
#include "rangeTables/range_50.h"
#include "rangeTables/range_75.h"
#include "rangeTables/range_100.h"
#include "rangeTables/range_125.h"
#include "rangeTables/range_150.h"
#include "rangeTables/range_175.h"
#include "rangeTables/range_200.h"
#include "rangeTables/range_225.h"
#include "rangeTables/range_250.h"
#include "rangeTables/range_275.h"
#include "rangeTables/range_300.h"
#include "rangeTables/range_325.h"
#include "rangeTables/range_350.h"
#include "rangeTables/range_375.h"
#include "rangeTables/range_400.h"
#include "rangeTables/range_425.h"
#include "rangeTables/range_450.h"
#include "rangeTables/range_475.h"
#include "rangeTables/range_500.h"
#include "rangeTables/range_525.h"
#include "rangeTables/range_550.h"
#include "rangeTables/range_575.h"
#include "rangeTables/range_600.h"
#include "rangeTables/range_625.h"
#include "rangeTables/range_650.h"
#include "rangeTables/range_675.h"
#include "rangeTables/range_700.h"




const double ZCu = 29;
const double ZoACu = ZCu / 63.546;
const double rhoCu = 8.960;
const double I0Cu = 322.0e-6;
const double aCu = 0.14339;
const double kCu = 2.9044;
const double x0Cu = -0.0254;
const double x1Cu = 3.2792;
const double CbarCu = 4.4190;
const double d0Cu = 0.08;

const double ZCc = 8.56;
const double ZoACc = 0.50274;
const double rhoCc = 2.300;
const double I0Cc = 135.2e-6;
const double aCc = 0.07515;
const double kCc = 3.5467;
const double x0Cc = 0.1301;
const double x1Cc = 3.0466;
const double CbarCc = 3.9464;
const double d0Cc = 0.00;

const double ZRock = 11;
const double ZoARock = 0.5;
const double rhoRock = 2.650;
const double I0Rock = 136.4e-6;
const double aRock = 0.08301;
const double kRock = 3.4120;
const double x0Rock = 0.0492;
const double x1Rock = 3.0549;
const double CbarRock = 3.7738;
const double d0Rock = 0.00;

using namespace std;

//-------------- magnetic field stuff ---------------------

// Structure to represent a 3D point with force components


class KDTree3D;

struct Magnet {
    std::vector<Point> points;
    std::unique_ptr<KDTree3D> kd_tree;
    Magnet(const std::vector<Point>& pts);
    double x_min, x_max, y_min, y_max, z_min, z_max;
};

inline Magnet::Magnet(const std::vector<Point> &pts) : points(pts), kd_tree(nullptr) {
    if (!points.empty()) {
        x_min = x_max = points[0].x;
        y_min = y_max = points[0].y;
        z_min = z_max = points[0].z;
        for (const auto &pt : points) {
            if (pt.x < x_min) x_min = pt.x; if (pt.x > x_max) x_max = pt.x;
            if (pt.y < y_min) y_min = pt.y; if (pt.y > y_max) y_max = pt.y;
            if (pt.z < z_min) z_min = pt.z; if (pt.z > z_max) z_max = pt.z;
        }
        kd_tree = std::make_unique<KDTree3D>(points); // build here
    } else {
        x_min = x_max = y_min = y_max = z_min = z_max = 0.0;
    }
}

std::vector<Magnet> all_magnets;

bool load_csv(const std::string &filepath, std::vector<Point> &points)
{
    std::ifstream file(filepath);
    if (!file.is_open())
    {
        std::cerr << "Failed to open " << filepath << "\n";
        return false;
    }

    std::string line;
    if (!std::getline(file, line))
    { // Skip header line
        std::cerr << "Empty file: " << filepath << "\n";
        return false;
    }

    while (std::getline(file, line))
    {
        std::stringstream ss(line);
        std::string item;
        std::vector<double> row;

        while (std::getline(ss, item, ','))
        {
            row.push_back(std::stod(item));
        }

        if (row.size() < 6)
            continue; // Ensure at least 6 values
        // Create a Point and add to points vector
        points.emplace_back(
            row[0] * 1e6, // x (converted to micrometers)
            row[1] * 1e6, // y (converted to micrometers)
            row[2] * 1e6, // z (converted to micrometers)
            row[3],       // Fx
            row[4],       // Fy
            row[5]        // Fz
        );
    }

    file.close();
    return !points.empty();
}




#include <limits>

static inline bool in_bounds_of(const Magnet &m, double x, double y, double z) {
    return !(x < m.x_min || x > m.x_max ||
             y < m.y_min || y > m.y_max ||
             z < m.z_min || z > m.z_max);
}

/*
std::vector<long double> BctAdv(const std::vector<Magnet> &magnets,
                                double x, double y, double z)
{
    static thread_local size_t last_idx = std::numeric_limits<size_t>::max();

    size_t idx = magnets.size();
    if (last_idx < magnets.size() && in_bounds_of(magnets[last_idx], x, y, z)) {
        idx = last_idx;
    } else {
        for (size_t i = 0; i < magnets.size(); ++i) {
            if (in_bounds_of(magnets[i], x, y, z)) { idx = i; break; }
        }
        if (idx == magnets.size()) return {0.0L, 0.0L, 0.0L};
        last_idx = idx;
    }

    const Magnet &m = magnets[idx];
    if (!m.kd_tree) return {0.0L, 0.0L, 0.0L};

    const Point p = m.kd_tree->find_closest_point(x, y, z);
    return { (long double)p.Fx, (long double)p.Fy, (long double)p.Fz };
}
*/

std::vector<double> BctAdv(const std::vector<Magnet> &magnets,
    double x, double y, double z)
{
static thread_local size_t last_idx = std::numeric_limits<size_t>::max();

auto in_bounds_of = [](const Magnet &m, double X, double Y, double Z)->bool {
return !(X < m.x_min || X > m.x_max ||
Y < m.y_min || Y > m.y_max ||
Z < m.z_min || Z > m.z_max);
};

size_t idx = magnets.size();
if (last_idx < magnets.size() && in_bounds_of(magnets[last_idx], x, y, z)) {
idx = last_idx;
} else {
for (size_t i = 0; i < magnets.size(); ++i) {
if (in_bounds_of(magnets[i], x, y, z)) { idx = i; break; }
}
if (idx == magnets.size()) return {0.0L, 0.0L, 0.0L};
last_idx = idx;
}

const Magnet &m = magnets[idx];
if (!m.kd_tree) return {0.0L, 0.0L, 0.0L};

constexpr int K = 8;            
constexpr double EPS = 1e-9L;

const auto neigh = m.kd_tree->k_closest_points(x, y, z, K);
if (neigh.empty()) return {0.0L, 0.0L, 0.0L};

double wsum = 0.0L, bx = 0.0L, by = 0.0L, bz = 0.0L;
for (const auto &pt : neigh) {
    const double dx = (double)x - (double)pt.x;
    const double dy = (double)y - (double)pt.y;
    const double dz = (double)z - (double)pt.z;
    const double d2 = dx*dx + dy*dy + dz*dz;
    const double w  = 1.0L / std::sqrt(d2 + EPS);   // IDW p=1
    bx += w * (double)pt.Fx;
    by += w * (double)pt.Fy;
    bz += w * (double)pt.Fz;
    wsum += w;
}
if (wsum == 0.0L) return {0.0L, 0.0L, 0.0L};
return { bx/wsum, by/wsum, bz/wsum };
}

void initializeFieldMaps()
{
    std::cout << "Initializing magnetic fields...\n";

    std::string export_dir = "./ExportedMagneticFields";
    std::vector<std::string> magnet_types = {"MainDipole", "D1", "D2", "InnerQuad", "RevInnerQuad"};
    const int max_retries = 5;  
    const int retry_delay_seconds = 2;

    // Define expected magnet counts for each type
    std::map<std::string, int> expected_counts = {
        {"MainDipole", 6},
        {"D1", 6},
        {"D2", 1},
        {"InnerQuad", 2},
        {"RevInnerQuad", 2}
    };

    // First pass: validate ALL files exist
    std::cout << "Validating magnetic field files...\n";
    for (const auto &magnet_type : magnet_types)
    {
        int expected = expected_counts[magnet_type];
        for (int idx = 1; idx <= expected; ++idx)
        {
            std::stringstream ss;
            ss << export_dir << "/" << magnet_type << "/" << magnet_type << "_magnet_" << idx << ".csv";
            std::string filepath = ss.str();
            
            if (!std::filesystem::exists(filepath))
            {
                std::cerr << "FATAL ERROR: Required file missing: " << filepath << std::endl;
                std::cerr << "Cannot proceed without all magnetic field files." << std::endl;
                exit(1);
            }
        }
    }
    std::cout << "All magnetic field files validated.\n";

    // Second pass: load ALL files sequentially with retries
    for (const auto &magnet_type : magnet_types)
    {
        int expected = expected_counts[magnet_type];
        
        for (int magnet_idx = 1; magnet_idx <= expected; ++magnet_idx)
        {
            std::stringstream ss;
            ss << export_dir << "/" << magnet_type << "/" << magnet_type << "_magnet_" << magnet_idx << ".csv";
            std::string filepath = ss.str();

            std::vector<Point> points;
            bool loaded = false;

            // Retry loading up to max_retries times
            for (int attempt = 1; attempt <= max_retries; ++attempt)
            {
                points.clear(); // Clear points before each attempt
                
                if (load_csv(filepath, points))
                {
                    Magnet magnet(points);
                    all_magnets.push_back(std::move(magnet));
                    std::cout << "Successfully loaded and initialized KD-tree for " << filepath << "\n";
                    loaded = true;
                    break;
                }
                else
                {
                    std::cerr << "Failed to load " << filepath << " (Attempt " << attempt << "/" << max_retries << ")\n";
                    if (attempt < max_retries)
                    {
                        std::cerr << "Retrying in " << retry_delay_seconds << " seconds...\n";
                        sleep(retry_delay_seconds);
                    }
                }
            }

            if (!loaded)
            {
                std::cerr << "FATAL ERROR: Failed to load " << filepath << " after " << max_retries << " attempts.\n";
                std::cerr << "Magnetic field configuration is incomplete. Exiting.\n";
                exit(1);
            }
        }
    }
    
    std::cout << "All magnetic fields loaded successfully. Total magnets: " << all_magnets.size() << "\n";
}



//-------------------- dE/dx funcitons ---------------------

/*
    The variables m (in GeV), z (in e), and \[Beta] (in light speed C) represent the mass, the electric charge number, and the velocity of the quirk particle, respectively;
    \[Delta]x (in cm) represents the distance traveled during this time step; The function EoxCu/Cc/RockGaus[m,z,\[Beta],\[Delta]x] (in 10^-16 GeV^2) provides the de/dx 
    value, which is normally distributed with EoxCu/Cc/RockAll[m,z,\[Beta]] (in 10^-16 GeV^2) as the mean and \[Sigma]Cu/Cc/Rock[m,z,\[Beta],\[Delta]x] (in 10^-16 GeV^2) as the standard deviation.
*/

static inline long double horner_desc(const long double *c, int n, long double x) {
    //for faster high power calcs
    long double y = c[0];
    for (int i = 1; i < n; ++i) y = y * x + c[i];
    return y;
}

static inline double sample_standard_normal(std::mt19937 &gen) {
    static thread_local std::normal_distribution<double> N01(0.0, 1.0);
    return N01(gen);
}

std::vector<double> Cross(const std::vector<double> &v1, const std::vector<double> &v2)
{
    // cross product function
    if (v1.size() != 3 || v2.size() != 3)
    {
        throw std::invalid_argument("Both vectors must be 3-dimensional");
    }
    std::vector<double> result(3);
    result[0] = v1[1] * v2[2] - v1[2] * v2[1];
    result[1] = v1[2] * v2[0] - v1[0] * v2[2];
    result[2] = v1[0] * v2[1] - v1[1] * v2[0];
    return result;
}

std::vector<long double> CrossLong(const std::vector<long double> &v1, const std::vector<long double> &v2)
{
    // cross product function with long's
    if (v1.size() != 3 || v2.size() != 3)
    {
        throw std::invalid_argument("Both vectors must be 3-dimensional");
    }
    std::vector<long double> result(3);
    result[0] = v1[1] * v2[2] - v1[2] * v2[1];
    result[1] = v1[2] * v2[0] - v1[0] * v2[2];
    result[2] = v1[0] * v2[1] - v1[1] * v2[0];
    return result;
}

double Gamma(double beta)
{
    return 1.0 / sqrt(1.0 - beta * beta);
}

double Emax(double m, double beta)
{
    return (2 * 0.511 * beta * beta * pow(Gamma(beta), 2)) /
           (1 + 2 * Gamma(beta) * (0.511e-3 / m) + pow(0.511e-3 / m, 2));
}

double Xi(double z, double ZoA, double rho, double beta)
{
    return 0.5 * 0.307075 * z * z * ZoA * rho / (beta * beta);
}

double Delta(double x, double x0, double x1, double Cbar, double a, double k, double d0)
{
    if (x >= x1)
    {
        return 2 * log(10) * x - Cbar;
    }
    else if (x >= x0)
    {
        return 2 * log(10) * x - Cbar + a * pow(x1 - x, k);
    }
    else
    {
        return d0 * pow(10, 2 * (x - x0));
    }
}

double Eox(double m, double z, double ZoA, double rho, double I0, double x0, double x1, double Cbar, double a, double k, double d0, double beta)
{

    return 2 * Xi(z, ZoA, rho, beta) * (0.5 * log((2 * 0.511 * beta * beta * pow(Gamma(beta), 2) * Emax(m, beta)) / pow(I0, 2)) - beta * beta - Delta(log10(beta * Gamma(beta)), x0, x1, Cbar, a, k, d0) / 2);
}

double EoxCuAll(double mq, int param, double beta)
{
    // de/dx copper
    // EoxCuAll with recasting variables to long double
    long double mq_ld = static_cast<long double>(mq);
    long double beta_ld = static_cast<long double>(beta);
    long double scalar;
    long double ZCu_eff = 1.0L;

    if (beta_ld <= 0.00226L)
    {
        scalar = 37597.30061169589L * beta_ld;
    }
    else if (beta_ld >= 0.06345454545454546L)
    {
        scalar = static_cast<long double>(Eox(static_cast<double>(mq_ld), static_cast<double>(ZCu_eff), ZoACu, rhoCu, I0Cu, x0Cu, x1Cu, CbarCu, aCu, kCu, d0Cu, static_cast<double>(beta_ld))) * 0.197L;
    }
    else
    {
        static const long double cu_desc[15] = {
            5.982648430710585e19L,
        -5.714216718459019e19L,
            2.496247979943447e19L,
        -6.596425471576249e18L,
            1.174756123051605e18L,
        -1.486143034696763e17L,
            1.370510669479835e16L,
        -9.294312877895761e14L,
            4.608165819030902e13L,
        -1.6320734910018296e12L,
            3.916027090833348e10L,
        -5.582148886272709e8L,
            2.6438521703577857e6L,
            33909.5576744394L,
            0.34289008715835223L
        };
        scalar = horner_desc(cu_desc, 15, beta_ld);
    }

    return static_cast<double>(scalar);
}

double EoxCcAll(double mq, int param, double beta)
{
    // de/dx concrete
    long double mq_ld = static_cast<long double>(mq);
    long double beta_ld = static_cast<long double>(beta);
    long double scalar;
    long double ZCc_eff = 1.0L;

    if (beta_ld <= 0.00226L)
    {
        scalar = 30376.62714732753L * beta_ld;
    }
    else if (beta_ld >= 0.06181818181818182L)
    {
        scalar = static_cast<long double>(Eox(static_cast<double>(mq_ld), static_cast<double>(ZCc_eff), ZoACc, rhoCc, I0Cc, x0Cc, x1Cc, CbarCc, aCc, kCc, d0Cc, static_cast<double>(beta_ld))) * 0.197L;
    }
    else
    {
        static const long double cc_desc[15] = {
            6.737738168445225e19L,
        -6.442273849826215e19L,
            2.819535817843903e19L,
        -7.470735431733813e18L,
            1.3350858443896056e18L,
        -1.695911162356092e17L,
            1.5707786950520584e16L,
        -1.0693146651849746e15L,
            5.310954532975338e13L,
        -1.8750617184047375e12L,
            4.441507306806682e10L,
        -6.152256215129855e8L,
            2.8807310255188923e6L,
            26377.245398907748L,
            0.3717416673986129L
        };
        scalar = horner_desc(cc_desc, 15, beta_ld);
    }

    return static_cast<double>(scalar);
}

double EoxRockAll(double mq, int param, double beta)
{
    // de/dx rock
    long double mq_ld = static_cast<long double>(mq);
    long double beta_ld = static_cast<long double>(beta);
    long double scalar;
    long double ZRock_eff = 1.0L;

    if (beta_ld <= 0.00226L)
    {
        scalar = 28340.291807946152L * beta_ld;
    }
    else if (beta_ld >= 0.05745454545454545L)
    {
        scalar = static_cast<long double>(Eox(static_cast<double>(mq_ld), static_cast<double>(ZRock_eff), ZoARock, rhoRock, I0Rock, x0Rock, x1Rock, CbarRock, aRock, kRock, d0Rock, static_cast<double>(beta_ld))) * 0.197L;
    }
    else
    {
        static const long double rock_desc[15] = {
            5.686153048402872e19L,
        -5.34284980622759e19L,
            2.30021301170228e19L,
        -6.003163825933505e18L,
            1.0585274314396489e18L,
        -1.3296907090779789e17L,
            1.2214854741842604e16L,
        -8.278484331611662e14L,
            4.113520947417071e13L,
        -1.462059229558537e12L,
            3.513441645396524e10L,
        -4.976688103007817e8L,
            2.350400267498349e6L,
            25065.834574193614L,
            0.3044358906484703L
        };
        scalar = horner_desc(rock_desc, 15, beta_ld);
    }

    return static_cast<double>(scalar);
}

// really the de/dx Gaus functions should use truncated distributions

/*double truncated_normal(double mean, double std_dev) {
    boost::math::normal_distribution<> normal_dist(mean, std_dev);
    boost::random::uniform_real_distribution<> uniform_dist(0.0, 1.0);

    double lower_cdf = boost::math::cdf(normal_dist, 0);
    double upper_cdf = boost::math::cdf(normal_dist, std::numeric_limits<double>::infinity());

    double u = uniform_dist(gen) * (upper_cdf - lower_cdf) + lower_cdf;

    // inverse CDF corresponding to the generated uniform random number
    return boost::math::quantile(normal_dist, u);
}*/


double EoxGaus(double m, double z, double ZoA, double rho, double I0, double x0, double x1, double Cbar, double a, double k, double d0, double beta, double delta_x, std::function<double(double, int, double)> EoxAllFunc, std::mt19937 &gen)
{
    double z_eff = 1;
    double mean = EoxAllFunc(m, z_eff, beta);
    double std_dev = 0.197 * std::sqrt(Xi(z_eff, ZoA, rho, beta) * delta_x * Emax(m, beta) * (1 - beta * beta / 2)) / delta_x;
    double z_draw = sample_standard_normal(gen);
    return mean + std_dev * z_draw;
}

// de/dx gausfor different materials
double EoxCuGaus(double mq, int param, const double beta, double dx, std::mt19937 &gen)
{
    return EoxGaus(mq, ZCu, ZoACu, rhoCu, I0Cu, x0Cu, x1Cu, CbarCu, aCu, kCu, d0Cu, beta, dx, EoxCuAll, gen);
}

double EoxCcGaus(double mq, int param, const double beta, double dx, std::mt19937 &gen)
{
    return EoxGaus(mq, ZCc, ZoACc, rhoCc, I0Cc, x0Cc, x1Cc, CbarCc, aCc, kCc, d0Cc, beta, dx, EoxCcAll, gen);
}

double EoxRockGaus(double mq, int param, const double beta, double dx, std::mt19937 &gen)
{
    return EoxGaus(mq, ZRock, ZoARock, rhoRock, I0Rock, x0Rock, x1Rock, CbarRock, aRock, kRock, d0Rock, beta, dx, EoxRockAll, gen);
}

std::vector<double> EoxCu(double mq, int param, const std::vector<double> &v)
{
    std::vector<double> result(v.size());
    for (size_t i = 0; i < v.size(); ++i)
    {
        result[i] = Eox(mq, ZCu, ZoACu, rhoCu, I0Cu, x0Cu, x1Cu, CbarCu, aCu, kCu, d0Cu, v[i]);
    }
    return result;
}

std::vector<double> EoxCc(double mq, int param, const std::vector<double> &v)
{
    std::vector<double> result(v.size());
    for (size_t i = 0; i < v.size(); ++i)
    {
        result[i] = Eox(mq, ZCc, ZoACc, rhoCc, I0Cc, x0Cc, x1Cc, CbarCc, aCc, kCc, d0Cc, v[i]);
    }
    return result;
}

std::vector<double> EoxRock(double mq, int param, const std::vector<double> &v)
{
    std::vector<double> result(v.size());
    for (size_t i = 0; i < v.size(); ++i)
    {
        result[i] = Eox(mq, ZRock, ZoARock, rhoRock, I0Rock, x0Rock, x1Rock, CbarRock, aRock, kRock, d0Rock, v[i]);
    }
    return result;
}

int Loct(double x, double y, double z)
{
    // determine location region of quirks
    if ((((sqrt(x * x + y * y) > 0.017e6) && (abs(z - 19.9e6) < 0.9e6)) ||
         ((abs(x) < (0.094 / 2) * 1e6) && (abs(y + (0.605 / 2 - 0.067) * 1e6) < (0.605 / 2) * 1e6) && (abs(z - 140.5e6) < 0.5e6)) ||
         (abs(z - 385.0e6) < 5.0e6) || (abs(z - 435.0e6) < 45.0e6)))
    {
        if ((sqrt(x * x + y * y) > 0.017e6) && (abs(z - 19.9e6) < 0.9e6))
            return 1;
        if ((abs(x) < (0.094 / 2) * 1e6) && (abs(y + (0.605 / 2 - 0.067) * 1e6) < (0.605 / 2) * 1e6) && (abs(z - 140.5e6) < 0.5e6))
            return 2;
        if (abs(z - 385.0e6) < 5.0e6)
            return 3;
        if (abs(z - 435.0e6) < 45.0e6)
            return 4;
    }
    return 0;
}

std::vector<double> Bct(double x, double y, double z)
{
    // B field function of location region
    if (((sqrt(x * x + y * y) < 0.06e6) && (abs(z - 72.287e6) < 12.365e6)) ||
        ((((sqrt((x - 0.093e6) * (x - 0.093e6) + y * y) < 0.04e6) || (sqrt((x + 0.093e6) * (x + 0.093e6) + y * y) < 0.04e6)) && (abs(z - 158.2e6) < 4.725e6))))
    {
        if ((sqrt(x * x + y * y) < 0.06e6) && (abs(z - 72.287e6) < 12.365e6))
            return {0, 3.5, 0};
        if (((sqrt((x - 0.093e6) * (x - 0.093e6) + y * y) < 0.04e6) || (sqrt((x + 0.093e6) * (x + 0.093e6) + y * y) < 0.04e6)) && (abs(z - 158.2e6) < 4.725e6))
            return {0, -3.5, 0};
    }
    return {0, 0, 0};
}

std::vector<long double> BctLong(long double x, long double y, long double z)
{
    // B long function

    if (((std::sqrt(x * x + y * y) < 0.06e6L) && (std::abs(z - 72.287e6L) < 12.365e6L)) ||
        ((((std::sqrt((x - 0.093e6L) * (x - 0.093e6L) + y * y) < 0.04e6L) ||
           (std::sqrt((x + 0.093e6L) * (x + 0.093e6L) + y * y) < 0.04e6L)) &&
          (std::abs(z - 158.2e6L) < 4.725e6L))))
    {
        if ((std::sqrt(x * x + y * y) < 0.06e6L) && (std::abs(z - 72.287e6L) < 12.365e6L))
        {
            return {0.0L, 3.5L, 0.0L};
        }
        if (((std::sqrt((x - 0.093e6L) * (x - 0.093e6L) + y * y) < 0.04e6L) ||
             (std::sqrt((x + 0.093e6L) * (x + 0.093e6L) + y * y) < 0.04e6L)) &&
            (std::abs(z - 158.2e6L) < 4.725e6L))
        {
            return {0.0L, -3.5L, 0.0L};
        }
    }
    return {0.0L, 0.0L, 0.0L};
}

int Layer(double x, double y, double z)
{
    // determine scintilaltor layers
    if (abs(x) < 0.15e6 && abs(y) < 0.15e6 && abs(z - 480.01e6) < 0.01e6)
        return 1;
    if (abs(x) < 0.2e6 && abs(y) < 0.2e6 && abs(z - 481.555e6) < 0.005e6)
        return 2;
    if (abs(x) < 0.15e6 && abs(y) < 0.15e6 && abs(z - 484.18e6) < 0.01e6)
        return 3;
    return 0;
}

// Helper functions for vector operations:
std::vector<double> SubtractVectors(const std::vector<double> &v1, const std::vector<double> &v2)
{
    return {v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]};
}

std::vector<double> AddVectors(const std::vector<double> &v1, const std::vector<double> &v2)
{
    return {v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]};
}

std::vector<double> MultiplyVector(const std::vector<double> &v, double scalar)
{
    return {v[0] * scalar, v[1] * scalar, v[2] * scalar};
}



inline std::vector<double> DivideVector(const std::vector<double>& v, double s){
  if (!std::isfinite(s) || std::abs(s) < 1e-15) s = (s>=0?1e-15:-1e-15);
  return {v[0]/s, v[1]/s, v[2]/s};
}


double DotProduct(const std::vector<double> &v1, const std::vector<double> &v2) {
    double sum=0.0, c=0.0;
    for (size_t i=0;i<v1.size();++i) {
        double y = v1[i]*v2[i] - c;
        double t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }
    return sum;
}

inline std::vector<double> Normalize(const std::vector<double>& v){
  double n = std::sqrt(DotProduct(v,v));
  if (n < 1e-15) n = 1e-15;
  return {v[0]/n, v[1]/n, v[2]/n};
}


std::vector<double> BoostToCOM(const std::vector<double>& p, double E, const std::vector<double>& Beta) {
    double beta_sq = DotProduct(Beta, Beta);
    if (beta_sq < 1e-15) {
        return p;
    }
    double gamma = 1.0 / std::sqrt(1.0 - beta_sq);
    double p_dot_beta = DotProduct(p, Beta);
    std::vector<double> p_COM = AddVectors(p, MultiplyVector(Beta, (gamma - 1.0) * p_dot_beta / beta_sq - gamma * E));
    return p_COM;
}



// Function to calculate the value of ct
double CalculateCt(const std::vector<double> &v, const std::vector<double> &Beta, const std::vector<double> &r1, const std::vector<double> &r2, const std::vector<double> &F, double E1, double E2)
{
    return 1 - DotProduct(v, Beta) - DotProduct(SubtractVectors(r1, r2), SubtractVectors(F, MultiplyVector(Beta, DotProduct(v, F)))) / (300000 * (E1 + E2));
}

// Function to calculate the travel distance
double CalculateDistance(const std::vector<double> &v, const std::vector<double> &p, double mq, double dt)
{
    std::vector<double> temp = AddVectors(v, DivideVector(p, std::sqrt(mq * mq + DotProduct(p, p))));
    return 30 * dt * std::sqrt(DotProduct(temp, temp)) / 2.0;
}

std::vector<double> CalculateForces(double mq, double Lambda, const std::vector<double> &v, const std::vector<double> &vc, const std::vector<double> &s, double vc0, double vp, int loct, int q, const std::vector<double> &r)
{
    // total forces on quirks

    double beta = 0.0;
    for (double component : v)
    {
        beta += component * component;
    }
    beta = std::sqrt(beta);
    // First term: -Lambda^2 / 100 * sqrt(1 - vc0^2) * s


    double term1_factor = -Lambda * Lambda / 100.0L * std::sqrt(1.0L - vc0* vc0);
    std::vector<double> term1 = MultiplyVector(s, term1_factor);

    // std::vector<double> term1 = MultiplyVector(s, -Lambda * Lambda / 100.0 * std::sqrt(1 - vc0 * vc0));
    // std::cout<<"term1: "<<term1[0]<<", "<<term1[1]<<", "<<term1[2]<<std::endl;

    double term2_factor = -Lambda * Lambda / 100.0L * vp / std::sqrt(1.0L - vc0 * vc0);
    std::vector<double> term2 = MultiplyVector(vc, term2_factor);

    // Second term: -Lambda^2 / 100 * vp / sqrt(1 - vc0^2) * vc

 
    std::vector<double> bct = BctAdv(all_magnets, r[0], r[1], r[2]);
    std::vector< double> crossProduct = Cross(v, bct);
    std::vector<double> term3 = MultiplyVector(crossProduct, 0.587L * q);
     
    // Fourth term: based on loct value
    double term4;
    switch (loct)
    {
    case 0:
        term4 = 0.0;
        break;
    case 1:
        term4 = EoxCuAll(mq, 1, beta);
        break;
    case 2:
        term4 = EoxCuAll(mq, 1, beta);

        break;
    case 3:
        term4 = EoxCcAll(mq, 1, beta);
        break;
    case 4:
        term4 = EoxRockAll(mq, 1, beta);
        break;
    default:
        throw std::invalid_argument("Invalid loct value");
    }

    std::vector<double> term4vec = MultiplyVector(Normalize(v), term4);

    // Summing up all terms
    std::vector<double> force(3);
    for (size_t i = 0; i < force.size(); ++i)
    {
        force[i] = (static_cast<double>(term1[i]) + static_cast<double>(term2[i]) + static_cast<double>(term3[i]) - term4vec[i]) / 6.58;
    }

    return force;
}

std::vector<double> CalculateForcesWithGaus(double mq, double Lambda, const std::vector<double> &v, const std::vector<double> &vc, const std::vector<double> &s, double vc0, double vp, int loct, int q, const std::vector<double> &r, double dx, std::mt19937 &gen)
{
    // total forces on quirks with gaus de/dex from materials
    
    double beta = 0.0;
    for (double component : v)
    {
        beta += component * component;
    }
    beta = std::sqrt(beta);
    // First term: -Lambda^2 / 100 * sqrt(1 - vc0^2) * s
    double sqrtTerm1 = std::sqrt(static_cast<double>(1.0) - vc0 * vc0);
    std::vector<double> term1 = MultiplyVector(s, -Lambda * Lambda / 100.0 * static_cast<double>(sqrtTerm1));

    // Second term: -Lambda^2 / 100 * vp / sqrt(1 - vc0^2) * vc
    double sqrtTerm2 = std::sqrt(1.0 - vc0 * vc0);
    std::vector<double> term2 = MultiplyVector(vc, -Lambda * Lambda / 100.0 * vp / sqrtTerm2);

    // Third term: 0.587 * q * Cross(v, Bct(r[0], r[1], r[2]))
    
    std::vector<double> bct = BctAdv(all_magnets, r[0], r[1], r[2]);
    // std::vector<long double> bct_long = BctLong(r[0], r[1], r[2]);

   
    std::vector<double> term3 = MultiplyVector(Cross(v, bct), 0.587L * q);

    // Fourth term: based on loct value with Gaussian variation
    double term4;
    switch (loct)
    {
    case 0:
        term4 = 0.0;
        break;
    case 1:
        term4 = EoxCuGaus(mq, 1, beta, dx, gen);

        break;
    case 2:
        term4 = EoxCuGaus(mq, 1, beta, dx, gen);

        break;
    case 3:
        term4 = EoxCcGaus(mq, 1, beta, dx, gen);

        break;
    case 4:
        term4 = EoxRockGaus(mq, 1, beta, dx, gen);

        break;
    default:
        throw std::invalid_argument("Invalid loct value");
    }

    std::vector<double> term4vec = MultiplyVector(Normalize(v), term4);
    // Summing up all terms
    std::vector<double> force(3);
    for (size_t i = 0; i < force.size(); ++i)
    {
        force[i] = (term1[i] + term2[i] + term3[i] - term4vec[i]) / 6.58;
    }

    return force;
}




static inline void SyncQuirksToSameTime(
    double t_star,
    std::vector<double>& r1, std::vector<double>& p1, double& t1, int q1,
    std::vector<double>& r2, std::vector<double>& p2, double& t2, int q2,
    double mq, double Lambda)
{
  auto v_from_p = [&](const std::vector<double>& p){
    double E = std::sqrt(mq*mq + DotProduct(p,p));
    return DivideVector(p, E);
  };

  auto advance_lag = [&](std::vector<double>& r,
                         std::vector<double>& p,
                         double& t,
                         const std::vector<double>& rO,
                         const std::vector<double>& pO,
                         int q,
                         double dt)
  {
    if (dt <= 0) return;

    // velocity at start
    std::vector<double> v = v_from_p(p);

    // string direction: unit vector from other quirk to this quirk
    std::vector<double> dr = SubtractVectors(r, rO);
    std::vector<double> s  = Normalize(dr);

    // decompose v into parallel / perpendicular to s
    double vpar = DotProduct(v, s);
    std::vector<double> vperp = SubtractVectors(v, MultiplyVector(s, vpar));
    double vperp0 = std::sqrt(DotProduct(vperp, vperp));

    // location/material
    int loct = Loct(r[0], r[1], r[2]);

   
    std::vector<double> F = CalculateForces(mq, Lambda, v, vperp, s, vperp0, vpar, loct, q, r);

    // trapezoidal update over dt
    std::vector<double> p_new = AddVectors(p, MultiplyVector(F, dt));
    std::vector<double> v_new = v_from_p(p_new);
    r = AddVectors(r, MultiplyVector(AddVectors(v, v_new), 300000.0 * dt * 0.5));
    p = p_new;
    t += dt;
  };

  if (t1 < t_star) advance_lag(r1, p1, t1, r2, p2, q1, t_star - t1);
  if (t2 < t_star) advance_lag(r2, p2, t2, r1, p1, q2, t_star - t2);
}


// -----------------------------------------------------------------------------------------------------------------------------
// Range-table based ionization-loss correction for the skipped 0 -> front segment (used when we start the simulation near `back`)
// -----------------------------------------------------------------------------------------------------------------------------

namespace RangeTables {

struct TableView {
  int n;
  const double* beta;
  const double* r_cu_um;
  const double* r_cc_um;
  const double* r_rock_um;
};

#define RT_RET(M) \
  return TableView{ range_m##M::RANGE_N, range_m##M::beta_grid, range_m##M::range_Cu_um, range_m##M::range_Cc_um, range_m##M::range_Rock_um };

static inline TableView get_table_for_mass(int mq_gev_int) {
  switch (mq_gev_int) {
    case 50:  RT_RET(50);
    case 75:  RT_RET(75);
    case 100: RT_RET(100);
    case 125: RT_RET(125);
    case 150: RT_RET(150);
    case 175: RT_RET(175);
    case 200: RT_RET(200);
    case 225: RT_RET(225);
    case 250: RT_RET(250);
    case 275: RT_RET(275);
    case 300: RT_RET(300);
    case 325: RT_RET(325);
    case 350: RT_RET(350);
    case 375: RT_RET(375);
    case 400: RT_RET(400);
    case 425: RT_RET(425);
    case 450: RT_RET(450);
    case 475: RT_RET(475);
    case 500: RT_RET(500);
    case 525: RT_RET(525);
    case 550: RT_RET(550);
    case 575: RT_RET(575);
    case 600: RT_RET(600);
    case 625: RT_RET(625);
    case 650: RT_RET(650);
    case 675: RT_RET(675);
    case 700: RT_RET(700);
    default:
      // Unsupported mass: return empty view.
      return TableView{0, nullptr, nullptr, nullptr, nullptr};
  }
}

#undef RT_RET

static inline double clamp01(double x) {
  if (x < 0.0) return 0.0;
  if (x > 1.0) return 1.0;
  return x;
}

static inline double beta_from_pE(const std::vector<double>& p, double E) {
  const double p2 = DotProduct(p, p);
  if (E <= 0.0) return 0.0;
  return std::sqrt(p2) / E;
}

static inline double energy_from_beta(double mq, double beta) {
  beta = clamp01(beta);
  if (beta >= 1.0) beta = 1.0 - 1e-15;
  const double gamma = 1.0 / std::sqrt(1.0 - beta * beta);
  return mq * gamma;
}

static inline double p_mag_from_beta(double mq, double beta) {
  beta = clamp01(beta);
  if (beta >= 1.0) beta = 1.0 - 1e-15;
  const double gamma = 1.0 / std::sqrt(1.0 - beta * beta);
  return mq * beta * gamma;
}

static inline double interp_monotone(const double* x, const double* y, int n, double xq) {
  // Linear interpolation on strictly increasing x.
  if (n <= 0) return 0.0;
  if (xq <= x[0]) return y[0];
  if (xq >= x[n - 1]) return y[n - 1];
  const double* it = std::lower_bound(x, x + n, xq);
  int hi = int(it - x);
  int lo = hi - 1;
  const double x0 = x[lo], x1 = x[hi];
  const double y0 = y[lo], y1 = y[hi];
  const double t = (xq - x0) / (x1 - x0);
  return y0 + t * (y1 - y0);
}

static inline double invert_R_to_beta(const TableView& tab, const double* R_um, double Rq_um) {
  // Given monotone increasing R(beta), return beta such that R(beta)=Rq_um.
  if (tab.n <= 0) return 0.0;
  if (Rq_um <= R_um[0]) return tab.beta[0];
  if (Rq_um >= R_um[tab.n - 1]) return tab.beta[tab.n - 1];
  const double* it = std::lower_bound(R_um, R_um + tab.n, Rq_um);
  int hi = int(it - R_um);
  int lo = hi - 1;
  const double R0 = R_um[lo], R1 = R_um[hi];
  const double b0 = tab.beta[lo], b1 = tab.beta[hi];
  const double t = (Rq_um - R0) / (R1 - R0);
  return b0 + t * (b1 - b0);
}

enum class Material { Cu, Cc, Rock };

static inline const double* range_array_for(Material m, const TableView& tab) {
  switch (m) {
    case Material::Cu:   return tab.r_cu_um;
    case Material::Cc:   return tab.r_cc_um;
    case Material::Rock: return tab.r_rock_um;
  }
  return nullptr;
}

static inline bool apply_material_range_step(
    const TableView& tab,
    Material mat,
    double L_um,
    double mq,
    double beta_min,
    std::vector<double>& p,
    double& E)
{
  if (L_um <= 0.0) return true;
  const double beta = beta_from_pE(p, E);
  if (beta < beta_min) return false;

  const double* R_um = range_array_for(mat, tab);
  if (!R_um) return false;

  const double R_old = interp_monotone(tab.beta, R_um, tab.n, beta);
  const double R_new = R_old - L_um;
  if (R_new <= 0.0) return false;

  const double beta_new = invert_R_to_beta(tab, R_um, R_new);
  if (beta_new < beta_min) return false;

  const double p_new_mag = p_mag_from_beta(mq, beta_new);
  const double p_old_mag = std::sqrt(DotProduct(p, p));
  if (p_old_mag <= 0.0) return false;

  p = MultiplyVector(p, p_new_mag / p_old_mag);
  E = energy_from_beta(mq, beta_new);
  return true;
}

// Apply a common ionization loss scaling to the pair momenta

static inline bool apply_material_range_step_common(const TableView& tab,Material mat,double L_um,double mq,double beta_min,std::vector<double>& p1,double& E1,std::vector<double>& p2,double& E2)
{
  if (L_um <= 0.0) return true;

  const double beta1 = beta_from_pE(p1, E1);
  const double beta2 = beta_from_pE(p2, E2);
  const double beta_rep = 0.5 * (beta1 + beta2);
  if (beta_rep < beta_min) return false;

  const double* R_um = range_array_for(mat, tab);
  if (!R_um) return false;

  const double R_old = interp_monotone(tab.beta, R_um, tab.n, beta_rep);
  const double R_new = R_old - L_um;
  if (R_new <= 0.0) return false;

  const double beta_new = invert_R_to_beta(tab, R_um, R_new);
  if (beta_new < beta_min) return false;

  const double p_rep_old = p_mag_from_beta(mq, beta_rep);
  const double p_rep_new = p_mag_from_beta(mq, beta_new);
  if (!(p_rep_old > 0.0)) return false;
  const double f = p_rep_new / p_rep_old;

  p1 = MultiplyVector(p1, f);
  p2 = MultiplyVector(p2, f);
  E1 = std::sqrt(mq * mq + DotProduct(p1, p1));
  E2 = std::sqrt(mq * mq + DotProduct(p2, p2));
  return true;
}

static inline double osc_path_factor(double k) {
  // Average over one period of sqrt(1 + k^2 cos^2 theta).
  // Small-k series: 1 + k^2/4 - 3k^4/64 + O(k^6)
  k = std::abs(k);
  const double PI = std::acos(-1.0);
  if (k < 0.2) {
    const double k2 = k * k;
    return 1.0 + 0.25 * k2 - (3.0 / 64.0) * k2 * k2;
  }
  // Simpson on [0, 2 pi]
  const int N = 400; // even
  const double a = 0.0;
  const double b = 2.0 * PI;
  const double h = (b - a) / N;
  auto f = [&](double t) {
    const double c = std::cos(t);
    return std::sqrt(1.0 + (k * k) * (c * c));
  };
  double s = f(a) + f(b);
  for (int i = 1; i < N; ++i) {
    s += (i % 2 ? 4.0 : 2.0) * f(a + i * h);
  }
  const double integral = (h / 3.0) * s;
  return integral / (2.0 * PI);
}

static inline bool apply_range_table_loss(int mq_int,double mq,double Lambda_eV,double z_end_um,double distance_period_m,  const std::vector<double>& Beta_pair,double beta_min,std::vector<double>& p1,double& E1,std::vector<double>& p2,double& E2,double& t_arrival_ns_out)
{
    //distance_period is in meters
  
  if (z_end_um <= 0.0) return true;
  if (beta_min <= 0.0) beta_min = 0.1;
  t_arrival_ns_out = 0.0;

  const TableView tab = get_table_for_mass(mq_int);
  if (tab.n <= 0) {
    std::cerr << "No range table for mq=" << mq_int << " GeV\n";
    return false;
  }

  // Require forward-going pair direction for the COM ray
  const double Beta_mag = std::sqrt(DotProduct(Beta_pair, Beta_pair));
  if (!(Beta_mag > 0.0)) return false;
  const double Beta_z = Beta_pair[2];
  if (Beta_z <= 0.0) return false;

  // Oscillation amplitude from COM energy :
  // rmax_um = (KE_total / Lambda_GeV^2) * hbarc_GeV_um ; A_each = rmax/2
  const double Lambda_GeV = Lambda_eV * 1e-9;
  if (!(Lambda_GeV > 0.0)) return false;

  const std::vector<double> p1_COM = BoostToCOM(p1, E1, Beta_pair);
  const std::vector<double> p2_COM = BoostToCOM(p2, E2, Beta_pair);
  const double E1_COM = std::sqrt(mq * mq + DotProduct(p1_COM, p1_COM));
  const double E2_COM = std::sqrt(mq * mq + DotProduct(p2_COM, p2_COM));
  const double KE_total = (E1_COM - mq) + (E2_COM - mq);
  if (!(KE_total >= 0.0)) return false;

  constexpr double hbarc_GeV_um = 1.9732697e-10;
  const double rmax_um = (KE_total / (Lambda_GeV * Lambda_GeV)) * hbarc_GeV_um;
  const double A_each_um = 0.5 * rmax_um;

  // Full sin  wavelength along the COM path:
  // distance_period_m is closest approach distance, so wavelength_sin = 2 * distance_period
  const double lambda_osc_um = 2.0 * distance_period_m * 1e6;
  if (!(lambda_osc_um > 0.0)) return false;

  const double PI = std::acos(-1.0);
  const double k = (2.0 * PI * A_each_um) / lambda_osc_um;
  const double osc_factor = osc_path_factor(k);

  // Convert z thickness to slant length along COM ray: L = dz / cosθz, cosθz = Beta_z/|Beta|
  const double cos_theta_z = Beta_z / Beta_mag; // Beta_z > 0 enforced above
  if (!(cos_theta_z > 0.0)) return false;

  auto com_xy_at_z = [&](double z_um) -> std::pair<double, double> {
    const double t = z_um / Beta_z;
    return { t * Beta_pair[0], t * Beta_pair[1] };
  };

  auto fraction_in_loct = [&](int loct_code, double z0_um, double z1_um) -> double {
    const int samples = 7;
    if (z1_um <= z0_um) return 0.0;
    int inside = 0;
    for (int i = 0; i < samples; ++i) {
      const double u = (i + 0.5) / samples;
      const double z = z0_um + u * (z1_um - z0_um);
      auto [x, y] = com_xy_at_z(z);
      if (Loct(x, y, z) == loct_code) inside++;
    }
    return double(inside) / double(samples);
  };

  struct Slab { double z0, z1; int loct; Material mat; };
  const Slab slabs[] = {
    // Match Loct() definitions
    {19.0e6, 20.8e6, 1, Material::Cu},        // TAS copper window
    {140.0e6, 141.0e6, 2, Material::Cu},      // TAN copper window
    {380.0e6, 390.0e6, 3, Material::Cc},      // concrete
    {390.0e6, 480.0e6, 4, Material::Rock},    // rock
  };

  // Coarse arrival time estimate to z=front (ns):
  // We want "arrival at a given z plane", so use dt = dz / (Beta_z * c).
  // Approximation: treat Beta_z constant in vacuum, and across concrete/rock use a trapezoid in 1/Beta_z
  // using the Beta_z before/after applying the corresponding ionization-loss step.

  const double c_um_per_ns = 300000.0;
  auto safe_Bz = [&](double bz) -> double {
    if (bz < 1e-6) return 1e-6;
    return bz;
  };
  auto beta_pair_z = [&](const std::vector<double>& pa, double Ea,
                         const std::vector<double>& pb, double Eb) -> double {
    const double Et = Ea + Eb;
    if (!(Et > 0.0)) return 0.0;
    return (pa[2] + pb[2]) / Et;
  };

  // Region boundaries (micrometers) consistent with Loct()
  const double z_conc_start_um = 380.0e6;
  const double z_conc_end_um   = 390.0e6;
  const double z_rock_start_um = 390.0e6;
  const double z_rock_end_um   = 480.0e6;

  // Beta_z checkpoints (computed from current p/E during the loss pass)
  const double Bz_init = Beta_pair[2];
  double Bz_after_conc = Bz_init;
  double Bz_after_rock = Bz_init;
  bool saw_conc = false;
  bool saw_rock = false;
  double Bz_in_conc = Bz_init, Bz_out_conc = Bz_init;
  double Bz_in_rock = Bz_init, Bz_out_rock = Bz_init;

  for (const auto& s : slabs) {
    if (s.z0 >= z_end_um) break;
    const double z_start = std::max(0.0, s.z0);
    const double z_end = std::min(z_end_um, s.z1);
    if (z_end <= z_start) continue;

    double frac = 1.0;
    // For TAS/TAN, apply transverse acceptance via Loct sampling
    if (s.loct == 1 || s.loct == 2) {
      frac = fraction_in_loct(s.loct, z_start, z_end);
    }
    if (frac <= 0.0) continue;

    const double dz_eff_um = (z_end - z_start) * frac;
    const double L_slant_um = (dz_eff_um / cos_theta_z);
    const double L_path_um = L_slant_um * osc_factor;

    if (s.mat == Material::Cc && !saw_conc) {
      saw_conc = true;
      Bz_in_conc = beta_pair_z(p1, E1, p2, E2);
    }
    if (s.mat == Material::Rock && !saw_rock) {
      saw_rock = true;
      Bz_in_rock = beta_pair_z(p1, E1, p2, E2);
    }

    if (!apply_material_range_step_common(tab, s.mat, L_path_um, mq, beta_min, p1, E1, p2, E2)) return false;

    if (s.mat == Material::Cc) {
      Bz_out_conc = beta_pair_z(p1, E1, p2, E2);
      Bz_after_conc = Bz_out_conc;
    }
    if (s.mat == Material::Rock) {
      Bz_out_rock = beta_pair_z(p1, E1, p2, E2);
      Bz_after_rock = Bz_out_rock;
    }
  }

  // Build dz segments to front (um)
  const double zf = z_end_um;
  // segment A: 0 -> min(front, 380m)
  const double dz_A = std::max(0.0, std::min(zf, z_conc_start_um) - 0.0);
  // segment B: 380m -> min(front, 390m)  (concrete window)
  const double dz_B = std::max(0.0, std::min(zf, z_conc_end_um) - z_conc_start_um);
  // segment C: 390m -> min(front, 480m)  (rock window)
  const double dz_C = std::max(0.0, std::min(zf, z_rock_end_um) - z_rock_start_um);
  // segment D: beyond 480m (vacuum)
  const double dz_D = std::max(0.0, zf - z_rock_end_um);

  // A: vacuum-ish, constant initial Beta_z
  const double dt_A = (dz_A / c_um_per_ns) * (1.0 / safe_Bz(Bz_init));

  // B: concrete, trapezoid in 1/Beta_z 
  double dt_B = 0.0;
  if (dz_B > 0.0) {
    const double Bzin = safe_Bz(saw_conc ? Bz_in_conc : Bz_init);
    const double Bzout = safe_Bz(saw_conc ? Bz_out_conc : Bz_after_conc);
    dt_B = (dz_B / c_um_per_ns) * 0.5 * ((1.0 / Bzin) + (1.0 / Bzout));
  }

  // C: rock, trapezoid in 1/Beta_z 
  double dt_C = 0.0;
  if (dz_C > 0.0) {
    const double Bzin = safe_Bz(saw_rock ? Bz_in_rock : Bz_after_conc);
    const double Bzout = safe_Bz(saw_rock ? Bz_out_rock : Bz_after_rock);
    dt_C = (dz_C / c_um_per_ns) * 0.5 * ((1.0 / Bzin) + (1.0 / Bzout));
  }

  // D: vacuum beyond rock end (unlikely this ever used..), constant Beta_z at end of rock
  const double dt_D = (dz_D / c_um_per_ns) * (1.0 / safe_Bz(Bz_after_rock));

  t_arrival_ns_out = dt_A + dt_B + dt_C + dt_D;

  return true;
}

// Apply range-table loss only over a z-span [z_start_um, z_end_um] (with z_end > z_start).
// This lets us "phase map" in stages without double-counting loss.
static inline bool apply_range_table_loss_zspan(int mq_int,double mq,double Lambda_eV,double z_start_um,double z_end_um,double distance_period_m,   const std::vector<double>& Beta_pair,double beta_min,std::vector<double>& p1,double& E1,std::vector<double>& p2,double& E2)
{
    // closest-approach distance (meters)
  if (z_end_um <= z_start_um) return true;
  if (beta_min <= 0.0) beta_min = 0.1;

  const TableView tab = get_table_for_mass(mq_int);
  if (tab.n <= 0) return false;

  const double Beta_mag = std::sqrt(DotProduct(Beta_pair, Beta_pair));
  const double Beta_z = Beta_pair[2];
  if (!(Beta_mag > 0.0) || !(Beta_z > 0.0)) return false;

  // amplitude/osc factor (same as in apply_range_table_loss)
  const double Lambda_GeV = Lambda_eV * 1e-9;
  if (!(Lambda_GeV > 0.0)) return false;

  const std::vector<double> p1_COM = BoostToCOM(p1, E1, Beta_pair);
  const std::vector<double> p2_COM = BoostToCOM(p2, E2, Beta_pair);
  const double E1_COM = std::sqrt(mq * mq + DotProduct(p1_COM, p1_COM));
  const double E2_COM = std::sqrt(mq * mq + DotProduct(p2_COM, p2_COM));
  const double KE_total = (E1_COM - mq) + (E2_COM - mq);
  constexpr double hbarc_GeV_um = 1.9732697e-10;
  const double rmax_um = (KE_total / (Lambda_GeV * Lambda_GeV)) * hbarc_GeV_um;
  const double A_each_um = 0.5 * rmax_um;

  const double lambda_osc_um = 2.0 * distance_period_m * 1e6; // wavelength_sin = 2*distance_period
  if (!(lambda_osc_um > 0.0)) return false;
  const double PI = std::acos(-1.0);
  const double k = (2.0 * PI * A_each_um) / lambda_osc_um;
  const double osc_factor = osc_path_factor(k);

  const double cos_theta_z = Beta_z / Beta_mag;
  if (!(cos_theta_z > 0.0)) return false;

  auto com_xy_at_z = [&](double z_um) -> std::pair<double, double> {
    const double t = z_um / Beta_z;
    return { t * Beta_pair[0], t * Beta_pair[1] };
  };

  auto fraction_in_loct = [&](int loct_code, double z0_um, double z1_um) -> double {
    const int samples = 7;
    if (z1_um <= z0_um) return 0.0;
    int inside = 0;
    for (int i = 0; i < samples; ++i) {
      const double u = (i + 0.5) / samples;
      const double z = z0_um + u * (z1_um - z0_um);
      auto [x, y] = com_xy_at_z(z);
      if (Loct(x, y, z) == loct_code) inside++;
    }
    return double(inside) / double(samples);
  };

  struct Slab { double z0, z1; int loct; Material mat; };
  const Slab slabs[] = {
    {19.0e6, 20.8e6, 1, Material::Cu},
    {140.0e6, 141.0e6, 2, Material::Cu},
    {380.0e6, 390.0e6, 3, Material::Cc},
    {390.0e6, 480.0e6, 4, Material::Rock},
  };

  for (const auto& s : slabs) {
    const double z0 = std::max(z_start_um, s.z0);
    const double z1 = std::min(z_end_um, s.z1);
    if (z1 <= z0) continue;

    double frac = 1.0;
    if (s.loct == 1 || s.loct == 2) frac = fraction_in_loct(s.loct, z0, z1);
    if (frac <= 0.0) continue;

    const double dz_eff_um = (z1 - z0) * frac;
    const double L_slant_um = (dz_eff_um / cos_theta_z);
    const double L_path_um = L_slant_um * osc_factor;

    if (!apply_material_range_step(tab, s.mat, L_path_um, mq, beta_min, p1, E1)) return false;
    if (!apply_material_range_step(tab, s.mat, L_path_um, mq, beta_min, p2, E2)) return false;
  }

  return true;
}

} // namespace RangeTables




// ##############################################################################################################################
//
//
//
// Main function
//
//
//
// ##############################################################################################################################

int main(int argc, char *argv[])
{

    initializeFieldMaps();
   
    double back = 474.6e6-0.2e6; //Vetonu scintillatorin faser coords-.2m buffer. Default back value in micrometers (vetoNu0), faser z=0 at 477.76
    double Lambda = 500.0; // Default lambda value in eV
    std::string inputFileName;
    int seed = 0;        // random seed
    int nquirks = -1;    // number of quirks to simulate
    int divStep = 10000; // not number of steps, step size is proportioal to Lambda squared/stepDen
    bool traj = false;   // trajectory output flag
    int skip = 0;
    int runNum = 0;
    double front = 19e6; // in micrometers
    double beta_cutOff = 0.1; // minimum beta to continue simulating
 

    for (int i = 1; i < argc; ++i)
    {
        std::string arg = argv[i];
        if (arg == "-b" && i + 1 < argc)
        {
            back = 1e6 * std::atof(argv[++i]);
        }
        else if (arg == "-l" && i + 1 < argc)
        {
            Lambda = std::atof(argv[++i]);
        }
        else if (arg == "-betaCut" && i + 1 < argc)
        {
            beta_cutOff = std::atof(argv[++i]);
        }
        else if (arg == "-skip" && i + 1 < argc)
        {
            skip = std::atof(argv[++i]);
        }
        else if (arg == "-r" && i + 1 < argc)
        {
            runNum = std::atof(argv[++i]);
        }
        else if (arg == "-n" && i + 1 < argc)
        {
            nquirks = std::atof(argv[++i]);
        }
        else if (arg == "-f" && i + 1 < argc)
        {
            front = 1e6 * std::atof(argv[++i]); //input in meters
        }
        else if (arg == "-s" && i + 1 < argc)
        {
            seed = std::atoi(argv[++i]);
        }
        else if (arg == "-t" && i + 1 < argc)
        {
            traj = true;
        }
        else if (arg == "-d" && i + 1 < argc)
        {
            divStep = std::atoi(argv[++i]);
        }
        else if (arg[0] != '-')
        {
            inputFileName = arg;
        }
        else
        {
            std::cerr << "Unknown option: " << arg << std::endl;
            std::cerr << "Usage: " << argv[0] << " [-b <back_value>] [-betaCut <min Beta cut off>] [-l <lambda_value>] [-s <seed>] [-n <# quirks>] [-d <stepsize divider>] [-skip <# events to skip>] [-runNum <run number>] [-t (trajectory output flag)] <input file>" << std::endl;
            return 1;
        }
    }

    std::mt19937 gen(seed); // initialize RNG with seed

    if (inputFileName.empty())
    {
        std::cerr << "Usage: " << argv[0] << " [-b <back_value>] [-l <lambda_value>] [-s <seed>] [-n <# quirks>] [-d <stepsize divider>] [-skip <# events to skip>] [-runNum <run number>] [-t (trajectory output flag)] <input file>" << std::endl;
        return 1;
    }

    std::filesystem::path inputPath(inputFileName);
    std::ifstream inputFile(inputFileName);
    std::string stem = inputPath.stem().string();

    // format Lambda without trailing zeros
    std::ostringstream lambdaStream;
    lambdaStream << std::fixed << Lambda;
    std::string lambdaStr = lambdaStream.str();
    lambdaStr.erase(lambdaStr.find_last_not_of('0') + 1);
    if (lambdaStr.back() == '.')
    {
        lambdaStr.pop_back();
    }

 
    std::ostringstream backStream;
    backStream << std::scientific << back;
    std::string backStr = backStream.str();


    size_t ePos = backStr.find('e');
    if (ePos != std::string::npos)
    {
        std::string exponent = backStr.substr(ePos + 1);
        if (exponent[0] == '+')
        {
            exponent.erase(0, 1);
        }

        std::string significant = backStr.substr(0, ePos);
        significant.erase(significant.find_last_not_of('0') + 1);
        if (significant.back() == '.')
        {
            significant.pop_back();
        }
        backStr = significant + "e" + exponent;
    }

    // output file name for quirks
    std::string outputFileName = stem + "_" + lambdaStr + "eV" + "_sd_" + std::to_string(seed) + "_" + std::to_string(runNum) + ".txt";
    std::ofstream outputFile(outputFileName);

    std::unique_ptr<std::ofstream> outputFileTrajectory;
    if (traj)
    {
        // output file name for quirk trajectory
        std::string outputFileTrajectoryName = stem + "_" + lambdaStr + "eV_trajectory.txt";
        outputFileTrajectory = std::make_unique<std::ofstream>(outputFileTrajectoryName);
    }

    if (!inputFile.is_open() || !outputFile.is_open())
    {
        std::cerr << "Error opening files!" << std::endl;
        return 1;
    }

    std::cout << "*****************************************************" << std::endl;
    std::cout << "Running pre-FASER quirk simulation with the following paramters: " << std::endl;
    std::cout << "Final distance: " << back / (1.0e6) << "m" << std::endl;
    std::cout << "Lambda: " << Lambda << "eV" << std::endl;
    std::cout << "Beta cut-off: " << beta_cutOff  << std::endl;
    if (nquirks == -1)
    {
        std::cout << "Number of quirks: All" << std::endl;
    }
    else
    {
        std::cout << "Number of quirks: " << nquirks << std::endl;
    }
    std::cout << "*****************************************************" << std::endl;

    // read data from inputFile and perform initial setup
    std::vector<std::vector<double>> data;
    std::string line;
    while (std::getline(inputFile, line))
    {
        std::vector<double> row;
        std::stringstream ss(line);
        double value;
        while (ss >> value)
        {
            row.push_back(value);
        }
        data.push_back(row);
    }

    int total = data.size() / 2;
    int start = std::min(skip, total);
    int count = (nquirks < 0) ? (total - start) : std::min(nquirks, total - start);
    int end = start + count;


    // after map load / bounds / KD init are done, before stepping:


    // Loop over quirks in file
    for (int h = start; h < end; ++h)
    {
        auto start = std::chrono::high_resolution_clock::now();
        // Set initial conditions
       

        int q1 = 1, q2 = -1;
        double mq = round(data[2 * h][6]); // Quirk mass in GeV
        double direc = (data[2 * h][4] + data[2 * h + 1][4] > 0) ? 1 : -1;

        std::vector<double> p1 = {direc * data[2 * h][2], direc * data[2 * h][3], direc * data[2 * h][4]};
        std::vector<double> p2 = {direc * data[2 * h + 1][2], direc * data[2 * h + 1][3], direc * data[2 * h + 1][4]};

        double E1 = sqrt(mq * mq + p1[0] * p1[0] + p1[1] * p1[1] + p1[2] * p1[2]);
        double E2 = sqrt(mq * mq + p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);



        // Compute survival probabilities before simulation begins
        double epsilons[3] = {0.07, 0.10, 0.13};
        double epsilon1 = 1e-15;          
        double l2 = 474.64 + 5.78;    // preshower1  distance from ip
        std::string model = "f31";      // fermionic colorless model

        double decay_dist[3];
        for (int i = 0; i < 3; ++i) {
            decay_dist[i] = DecayDistance(epsilons[i],epsilon1,Lambda,mq,model,p1[0], p1[1], p1[2],p2[0], p2[1], p2[2]);
        }
        
        double decay_dist_stddev = DecayStandardDeviation(Lambda,mq,p1[0], p1[1], p1[2], E1,p2[0], p2[1], p2[2], E2);
        
        
        double survival_prob1 = LifetimeSurvivalProbGauss(decay_dist[0],decay_dist_stddev,l2);
        double survival_prob2 = LifetimeSurvivalProbGauss(decay_dist[1],decay_dist_stddev,l2);
        double survival_prob3 = LifetimeSurvivalProbGauss(decay_dist[2],decay_dist_stddev,l2);

        // Per-event transverse smearing widths at tracker plane (micrometers), for the three epsilon points
        double sigmaR[3];
        for (int i = 0; i < 3; ++i) {
            sigmaR[i] = SigmaR_um(epsilons[i], l2, Lambda, mq,
                                  p1[0], p1[1], p1[2],
                                  p2[0], p2[1], p2[2]);
        }

        if (survival_prob1 == 0.0 &&survival_prob2 == 0.0 && survival_prob3 == 0.0)
        {
            std::cout << "Quirk pair " << h << " skipped due to all survival probabilities being 0.0" << std::endl;
            continue;  // skip this quirk pair entirely
            
        }


        std::vector<double> v1 = {p1[0] / E1, p1[1] / E1, p1[2] / E1};
        std::vector<double> v2 = {p2[0] / E2, p2[1] / E2, p2[2] / E2};

        double v10 = sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);
        double v20 = sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);

        std::vector<double> Beta = {(p1[0] + p2[0]) / (E1 + E2), (p1[1] + p2[1]) / (E1 + E2), (p1[2] + p2[2]) / (E1 + E2)};
        std::vector<long double> p1_long(3);
        std::vector<long double> p2_long(3);
        long double E1_long = static_cast<double long>(E1);
        long double E2_long = static_cast<double long>(E2);

        for (int i = 0; i < p1.size(); ++i)
        {
            p1_long[i] = static_cast<long double>(p1[i]);
            p2_long[i] = static_cast<long double>(p2[i]);
        }

        std::vector<long double> Beta_long = {(p1_long[0] + p2_long[0]) / (E1_long + E2_long), (p1_long[1] + p2_long[1]) / (E1_long + E2_long), (p1_long[2] + p2_long[2]) / (E1_long + E2_long) };

        long double mq_long = static_cast<long double>(mq);
        long double Lambda_long = static_cast<long double>(Lambda);

        long double t1q_long = 658 * ((2 * mq_long) / (Lambda_long * Lambda_long)) * sqrt(pow((E1_long + E2_long) / (2 * mq_long), 2) - 1 / (1 - (Beta_long[0] * Beta_long[0] + Beta_long[1] * Beta_long[1] + Beta_long[2] * Beta_long[2])));

        double t1q = static_cast<double>(t1q_long);

       
        double beta_mag = std::sqrt(Beta[0]*Beta[0] + Beta[1]*Beta[1] + Beta[2]*Beta[2]);
        const double c = 2.99792458e8;  
        double distance_period = beta_mag * c * t1q * 1e-9;  // meters
        std::cout<<"closest approach interval: " << distance_period << " m" << std::endl;
        // Decide whether we're using the "within half-oscillation" shortcut between front and back.
        double half_osc_length = distance_period * 1e6; // (meters -> micrometers) for closest-approach interval
        const double eps = 1e-9;
        bool within_half = (back - front) <= (half_osc_length * (1.0 + eps));

        // ------------------------------------------------------------------
        // Phase mapping / initialization
        // We first compute the original (pre-loss) phase-mapped start position
        // (r1=r2) exactly as before, then (if within_half) we apply ionization
        // loss to momenta and recompute ONLY the start times t1/t2 using the
        // post loss Beta_z and t1q, while keeping r1/r2 fixed 
        // ------------------------------------------------------------------

        // Original pre-loss phase map to the start plane (near z=front)
        int nsf0 = floor(front / (3e5 * t1q * Beta[2]));
        int ns0 = (nsf0 % 2 == 0) ? nsf0 : nsf0 - 1;
        double t1_pre = ns0 * t1q;
        double t2_pre = t1_pre;
        std::vector<double> r1_pre = {3e5 * ns0 * t1q * Beta[0], 3e5 * ns0 * t1q * Beta[1], 3e5 * ns0 * t1q * Beta[2]};
        std::vector<double> r2_pre = r1_pre;
        const double z_start = r1_pre[2];

        // If we start the simulation at `front` near `back`, apply a fast ionization-loss correction for the skipped 0 -> front segment.
        if (within_half && front > 0.0) {
            const int mq_int = static_cast<int>(std::llround(mq));
            auto recompute_kin = [&]() {
                v1 = DivideVector(p1, E1);
                v2 = DivideVector(p2, E2);
                v10 = std::sqrt(DotProduct(v1, v1));
                v20 = std::sqrt(DotProduct(v2, v2));
                Beta = {(p1[0] + p2[0]) / (E1 + E2), (p1[1] + p2[1]) / (E1 + E2), (p1[2] + p2[2]) / (E1 + E2)};

                for (int i = 0; i < 3; ++i) {
                    p1_long[i] = static_cast<long double>(p1[i]);
                    p2_long[i] = static_cast<long double>(p2[i]);
                }
                E1_long = static_cast<long double>(E1);
                E2_long = static_cast<long double>(E2);
                Beta_long = {(p1_long[0] + p2_long[0]) / (E1_long + E2_long),
                             (p1_long[1] + p2_long[1]) / (E1_long + E2_long),
                             (p1_long[2] + p2_long[2]) / (E1_long + E2_long)};
                mq_long = static_cast<long double>(mq);
                Lambda_long = static_cast<long double>(Lambda);
                t1q_long = 658 * ((2 * mq_long) / (Lambda_long * Lambda_long)) *
                           sqrt(pow((E1_long + E2_long) / (2 * mq_long), 2) -
                                1 / (1 - (Beta_long[0] * Beta_long[0] + Beta_long[1] * Beta_long[1] + Beta_long[2] * Beta_long[2])));
                t1q = static_cast<double>(t1q_long);
                beta_mag = std::sqrt(Beta[0] * Beta[0] + Beta[1] * Beta[1] + Beta[2] * Beta[2]);
                distance_period = beta_mag * c * t1q * 1e-9;  // meters
                half_osc_length = distance_period * 1e6;
                within_half = (back - front) <= (half_osc_length * (1.0 + eps));
            };

            // Apply ionization loss to momenta for the skipped 0 -> front segment.
            // (We keep r1/r2 fixed to the pre-loss placement computed above.)
            double unused_tof = 0.0;
            const bool ok = RangeTables::apply_range_table_loss(
                mq_int, mq, Lambda, front, distance_period, Beta, beta_cutOff, p1, E1, p2, E2, unused_tof
            );
            if (!ok) continue;

            // recompute post-loss Beta and t1q for the TOF/phase correction
            recompute_kin();

            // recompute the phase mapped time using the fixed start z (from the original placement).
         
            int nsf_new = floor(z_start / (3e5 * t1q * Beta[2]));
            int ns_new = (nsf_new % 2 == 0) ? nsf_new : nsf_new - 1;
            t1_pre = ns_new * t1q;
            t2_pre = t1_pre;

            
        }

        double dt = std::min(0.03, t1q / divStep);

        // Final start state:
        // - positions are the original pre-loss placement (r1_pre/r2_pre)
        // - times are corrected (t1_pre/t2_pre), using post-loss Beta_z and t1q but fixed z_start
        double t1 = t1_pre;
        double t2 = t2_pre;
        std::vector<double> r1 = r1_pre;
        std::vector<double> r2 = r2_pre;

        
        int stepcount = 0;
        int n = 1;
        double lastSaveTime = 0;
        double saveInterval = .1; // nano seconds
        double dx1pre = 0.0, dx2pre = 0.0;

        double momentum_diff_max = 0.0;  // Maximum momentum difference in COM frame
        std::deque<double> momentum_diff_window;  // Store momentum differences in COM frame
        struct Snapshot
        {
            std::vector<double> r1, r2, p1, p2;
            double t1, t2;
            int trajectory_lines;  // Number of trajectory lines written up to this point
        };
        std::deque<Snapshot> state_window;
     
        // half_osc_length / within_half already defined above (and recomputed if we applied 0->front energy loss)
        
        // Calculate the z-position of the second-to-last meeting point before back
        // Meeting points occur every osc_length, so second-to-last is at back - half_osc_length
        double window_factor = 1.5;
        double second_to_last_meeting_z = back - window_factor * half_osc_length;
        bool trackingMinimum = false;  // Flag to start tracking once past second-to-last meeting (keep name for consistency)
        int stepsSinceTrackingStart = 0;
        int deque_size = static_cast<int>(divStep * window_factor);  // Deque size based on divStep
        int trajectory_steps_written = 0;  // Track how many trajectory points we've written
        bool shouldSave = false;  // Only save if we hit back or within_half, not if too slow/transverse


        // main step loop
        while (!((sqrt(Beta[0] * Beta[0] + Beta[1] * Beta[1] + Beta[2] * Beta[2]) < beta_cutOff) ||
                 (sqrt(((r1[0] + r2[0]) / 2) * ((r1[0] + r2[0]) / 2) + ((r1[1] + r2[1]) / 2) * ((r1[1] + r2[1]) / 2)) > 1.5e6)))
        { // if quirks transverse cm goes a 2.0m off beamline, or too slow cancel event

            int loct1 = Loct(r1[0], r1[1], r1[2]);
            int loct2 = Loct(r2[0], r2[1], r2[2]);

            // int layer1i = Layer(r1[0], r1[1], r1[2]);
            // int layer2i = Layer(r2[0], r2[1], r2[2]);
            stepcount++;

            // Recalculate energies and velocities
            E1 = sqrt(mq * mq + p1[0] * p1[0] + p1[1] * p1[1] + p1[2] * p1[2]);
            v1 = DivideVector(p1, E1);
            v10 = sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);

            E2 = sqrt(mq * mq + p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);
            v2 = DivideVector(p2, E2);
            v20 = sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);

            Beta = {(p1[0] + p2[0]) / (E1 + E2), (p1[1] + p2[1]) / (E1 + E2), (p1[2] + p2[2]) / (E1 + E2)};

            // Direction of the string at quirk 1
            std::vector<double> s1(3), s2(3);
            if (n == 1)
            {
                s1 = Normalize(SubtractVectors(v1, v2));
            }
            else
            {
                s1 = Normalize(AddVectors(MultiplyVector(SubtractVectors(SubtractVectors(r1, r2), MultiplyVector(Beta, 300000 * (t1 - t2))), (1 - DotProduct(Beta, Beta))), MultiplyVector(SubtractVectors(Beta, v1), DotProduct(SubtractVectors(SubtractVectors(r1, r2), MultiplyVector(Beta, 300000 * (t1 - t2))), Beta))));
            }

            double vp1 = DotProduct(v1, s1);
            std::vector<double> vc1 = SubtractVectors(v1, MultiplyVector(s1, vp1));
            double vc10 = sqrt(DotProduct(vc1, vc1));

            // Direction of the string at quirk 2
            if (n == 1)
            {
                s2 = Normalize(SubtractVectors(v2, v1));
            }
            else
            {
                s2 = Normalize(AddVectors(MultiplyVector(SubtractVectors(SubtractVectors(r2, r1), MultiplyVector(Beta, 300000 * (t2 - t1))), (1 - DotProduct(Beta, Beta))), MultiplyVector(SubtractVectors(Beta, v2), DotProduct(SubtractVectors(SubtractVectors(r2, r1), MultiplyVector(Beta, 300000 * (t2 - t1))), Beta))));
            }

            double vp2 = DotProduct(v2, s2);
            std::vector<double> vc2 = SubtractVectors(v2, MultiplyVector(s2, vp2));
            double vc20 = sqrt(DotProduct(vc2, vc2));

            // Estimation of the travel distance (in cm) using the average de/dx value

            if (loct1 > 0 || loct2 > 0)
            {

                std::vector<double> F1pre = CalculateForces(mq, Lambda, v1, vc1, s1, vc10, vp1, loct1, q1, r1);
                std::vector<double> F2pre = CalculateForces(mq, Lambda, v2, vc2, s2, vc20, vp2, loct2, q2, r2);

                double ct1pre = CalculateCt(v1, Beta, r1, r2, F1pre, E1, E2);
                double ct2pre = CalculateCt(v2, Beta, r2, r1, F2pre, E1, E2);

                double dt1pre, dt2pre;
                if (abs(ct1pre) < abs(ct2pre))
                {
                    dt1pre = dt;
                    dt2pre = dt1pre * ct1pre / ct2pre;
                }
                else
                {
                    dt2pre = dt;
                    dt1pre = dt2pre * ct2pre / ct1pre;
                }

                std::vector<double> p1pre = AddVectors(p1, MultiplyVector(F1pre, dt1pre));
                std::vector<double> p2pre = AddVectors(p2, MultiplyVector(F2pre, dt2pre));

                dx1pre = CalculateDistance(v1, p1pre, mq, dt1pre);
                dx2pre = CalculateDistance(v2, p2pre, mq, dt2pre);
            }

            // Recalculate forces using normally distributed de/dx
            std::vector<double> F1 = CalculateForcesWithGaus(mq, Lambda, v1, vc1, s1, vc10, vp1, loct1, q1, r1, dx1pre, gen);
            std::vector<double> F2 = CalculateForcesWithGaus(mq, Lambda, v2, vc2, s2, vc20, vp2, loct2, q2, r2, dx2pre, gen);

            double ct1 = CalculateCt(v1, Beta, r1, r2, F1, E1, E2);
            double ct2 = CalculateCt(v2, Beta, r2, r1, F2, E1, E2);

            double dt1, dt2;

            if (abs(ct1) < abs(ct2))
            {
                dt1 = dt;
                dt2 = dt1 * ct1 / ct2;
            }
            else
            {
                dt2 = dt;
                dt1 = dt2 * ct2 / ct1;
            }

            // Update quirk momentum and position
            
            p1 = AddVectors(p1, MultiplyVector(F1, dt1));
            p2 = AddVectors(p2, MultiplyVector(F2, dt2));

            r1 = AddVectors(r1, MultiplyVector(AddVectors(v1, DivideVector(p1, sqrt(mq * mq + DotProduct(p1, p1)))), 300000.0 * dt1 / 2));
            r2 = AddVectors(r2, MultiplyVector(AddVectors(v2, DivideVector(p2, sqrt(mq * mq + DotProduct(p2, p2)))), 300000.0 * dt2 / 2));

            t1 += dt1;
            t2 += dt2;

 
            if (!std::isfinite(r1[0]) || !std::isfinite(r1[1]) || !std::isfinite(r1[2]) ||
                !std::isfinite(r2[0]) || !std::isfinite(r2[1]) || !std::isfinite(r2[2])) {
                std::cerr << "NaN detected in positions at event " << h << ", skipping.\n";
                break; // skip this event
            }

        

            // Determine the detector scintillators, currently not used
            // int layer1f = Layer(r1[0], r1[1], r1[2]);
            // int layer2f = Layer(r2[0], r2[1], r2[2]);

            // write trajectory info to file
            if (traj && outputFileTrajectory && outputFileTrajectory->is_open())
            {
                if (t1 - lastSaveTime >= saveInterval)
                {
                    
                    double pair_px = p1[0] + p2[0];
                    double pair_py = p1[1] + p2[1];
                    double pair_pz = p1[2] + p2[2];
                    double pair_p_mag = sqrt(pair_px * pair_px + pair_py * pair_py + pair_pz * pair_pz);
                    double pair_speed = pair_p_mag / (E1 + E2);
                    
                    *outputFileTrajectory << std::setprecision(16) << t1 << " " << r1[0] << " " << r1[1] << " " << r1[2] << " " << pair_speed << "\n";
                    *outputFileTrajectory << std::setprecision(16) << t1 << " " << r2[0] << " " << r2[1] << " " << r2[2] << " " << pair_speed << "\n";
                    lastSaveTime = t1;
                    trajectory_steps_written += 2;  
                }
            }

            if (stepcount % 100000 == 0)
            {
                std::cout << "r1: " << r1[0] << " " << r1[1] << " " << r1[2] << std::endl;
                std::cout << "r2: " << r2[0] << " " << r2[1] << " " << r2[2] << std::endl;
                std::cout << "beta: " << sqrt(Beta[0] * Beta[0] + Beta[1] * Beta[1] + Beta[2] * Beta[2]) << std::endl;
            }


            // Calculate momentum difference in COM frame
            // Boost momenta to COM frame and calculate |p1_COM - p2_COM|
            std::vector<double> p1_COM = BoostToCOM(p1, E1, Beta);
            std::vector<double> p2_COM = BoostToCOM(p2, E2, Beta);
            std::vector<double> p_diff = SubtractVectors(p1_COM, p2_COM);
            double momentum_diff = sqrt(DotProduct(p_diff, p_diff));  // |p1_COM - p2_COM|

            // Check if we've passed the second-to-last meeting point and start tracking (using OR)
            if (!trackingMinimum && (r1[2] >= second_to_last_meeting_z || r2[2] >= second_to_last_meeting_z))
            {
                trackingMinimum = true;
                momentum_diff_max = momentum_diff;
            }

            if (trackingMinimum)
            {
                momentum_diff_window.push_back(momentum_diff);
                state_window.push_back({r1,r2,p1,p2,t1,t2,trajectory_steps_written});

                if (momentum_diff_window.size() > deque_size) {
                    momentum_diff_window.pop_front();
                    state_window.pop_front();
                }
            }
            
            // Update maximum momentum difference while tracking
            if (trackingMinimum)
            {
                if (momentum_diff > momentum_diff_max)
                {
                    momentum_diff_max = momentum_diff;
                }
            }

            // Only break if within_half (separate pathway) - output done after loop
            if (within_half)
            {
                shouldSave = true;
                break;
            }
            
            // Break if we hit back (not within_half) - will search deque after loop
            if (!within_half && (r1[2] >= back || r2[2] >= back))
            {
                shouldSave = true;
                break;
            }

            n++;
        }
        
        // After loop: if we hit back (not within_half), search deque for maximum momentum difference
        Snapshot maxSnapshot;
        if (!within_half && (r1[2] >= back || r2[2] >= back) && trackingMinimum && momentum_diff_window.size() > 0)
        {
            // Find maximum in deque
            int maxIdx = 0;
            double maxMomentumDiff = momentum_diff_window[0];
            for (size_t i = 1; i < momentum_diff_window.size(); ++i) {
                if (momentum_diff_window[i] > maxMomentumDiff) {
                    maxMomentumDiff = momentum_diff_window[i];
                    maxIdx = i;
                }
            }
            maxSnapshot = state_window[maxIdx];
            momentum_diff_max = maxMomentumDiff;
            
            // Restore to maximum momentum difference position (closest approach)
            r1 = maxSnapshot.r1;
            r2 = maxSnapshot.r2;
            p1 = maxSnapshot.p1;
            p2 = maxSnapshot.p2;
            t1 = maxSnapshot.t1;
            t2 = maxSnapshot.t2;
            
            // Truncate trajectory file to the point where maximum occurred
            if (traj && outputFileTrajectory) {
                if (outputFileTrajectory->is_open()) {
                    outputFileTrajectory->close();
                }
                
                std::string trajFileName = stem + "_" + lambdaStr + "eV_trajectory.txt";
                std::ifstream trajIn(trajFileName);
                std::vector<std::string> lines;
                std::string line;
                while (std::getline(trajIn, line)) {
                    lines.push_back(line);
                }
                trajIn.close();
                
                // Keep only the first trajectory_lines from the maximum snapshot
                int lines_to_keep = maxSnapshot.trajectory_lines;
                if (lines_to_keep > 0 && lines_to_keep <= static_cast<int>(lines.size())) {
                    lines.erase(lines.begin() + lines_to_keep, lines.end());
                }
                
                // Write back truncated file
                std::ofstream trajOut(trajFileName);
                for (const auto& l : lines) {
                    trajOut << l << "\n";
                }
                trajOut.close();
            }
        }


        double t_star = (t1 > t2) ? t1 : t2;
        SyncQuirksToSameTime(t_star, r1, p1, t1, q1, r2, p2, t2, q2, mq, Lambda);

        auto end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> duration = end - start;

        // Calculate distance at closest approach point
        double dist_at_closest = sqrt((r1[0] - r2[0]) * (r1[0] - r2[0]) + (r1[1] - r2[1]) * (r1[1] - r2[1]) + (r1[2] - r2[2]) * (r1[2] - r2[2]));
        std::cout << "Closest approach found at z = " << r1[2] << " (r1), " << r2[2] << " (r2) with distance: " << dist_at_closest << " and momentum diff (COM): " << momentum_diff_max << std::endl;
        std::cout << "Time taken: " << duration.count() << " seconds" << std::endl;


        
        if (shouldSave){
        // Sync and output (for both within_half and deque cases)
    
        outputFile << std::setprecision(16) << h << " " << mq << " " << Lambda << " " << t1q << " 1 " << 1 << " " << t1 << " "
                   << r1[0] << " " << r1[1] << " " << r1[2] << " " << p1[0] << " " << p1[1] << " " << p1[2] << " " << duration.count()
                   << " " << survival_prob1 << " " << survival_prob2 << " " << survival_prob3
                   << " " << sigmaR[0] << " " << sigmaR[1] << " " << sigmaR[2] << "\n";
        outputFile << std::setprecision(16) << h << " " << mq << " " << Lambda << " " << t1q << " 2 " << 1 << " " << t2 << " "
                   << r2[0] << " " << r2[1] << " " << r2[2] << " " << p2[0] << " " << p2[1] << " " << p2[2] << " " << duration.count()
                   << " " << survival_prob1 << " " << survival_prob2 << " " << survival_prob3
                   << " " << sigmaR[0] << " " << sigmaR[1] << " " << sigmaR[2] << "\n";
        }
        // Debug: why did loop exit?
        double final_beta = sqrt(Beta[0] * Beta[0] + Beta[1] * Beta[1] + Beta[2] * Beta[2]);
        double final_trans = sqrt(((r1[0] + r2[0]) / 2) * ((r1[0] + r2[0]) / 2) + ((r1[1] + r2[1]) / 2) * ((r1[1] + r2[1]) / 2));
        std::cout << "DEBUG: Loop exited. beta=" << final_beta << " (cutoff=" << beta_cutOff << "), trans_dist=" << final_trans << " (limit=1.5e6)" << std::endl;
        std::cout << h << std::endl;
      
    }

    inputFile.close();
    outputFile.close();

    if (traj && outputFileTrajectory)
    {
        outputFileTrajectory->close();
    }

    return 0;
}